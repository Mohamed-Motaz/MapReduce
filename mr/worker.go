package mr

import (
	"encoding/json"
	"fmt"
	"hash/fnv"
	"io/ioutil"
	"log"
	"net/rpc"
	"os"
	"sort"
)

// for sorting by key.
type ByKey []KeyValue

// for sorting by key.
func (a ByKey) Len() int           { return len(a) }
func (a ByKey) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }
func (a ByKey) Less(i, j int) bool { return a[i].Key < a[j].Key }

//
// use ihash(key) % NReduce to choose the reduce
// task number for each KeyValue emitted by Map.
//
func ihash(key string) int {
	h := fnv.New32a()
	h.Write([]byte(key))
	return int(h.Sum32() & 0x7fffffff)
}


//get fileName of files based on mapNum and reduceNum
//this is so reduce tasks can get the names of the files generated by
//the maps for them
func getIntermediateFileName(mapTaskNum int, reduceTaskNum int) string{
	return fmt.Sprintf("mr-%d-%d", mapTaskNum, reduceTaskNum);
}

func finalizeRenameTemporaryIntermediateFiles(currentFileName string, mapTaskNum int, reduceTaskNum int){
	newIntermediateFileName := getIntermediateFileName(mapTaskNum, reduceTaskNum)
	os.Rename(currentFileName, newIntermediateFileName);
}

func finalizeRenameReduceTasks(currentFileName string, taskNum int){
	finalFileName := fmt.Sprintf("mr-out-%d", taskNum);
	os.Rename(currentFileName, finalFileName);
} 

//
// main/mrworker.go calls this function.
//
func Worker(mapf func(string, string) []KeyValue,
	reducef func(string, []string) string) {

	//need to call the coordinator and tell him I am alive and ready
	for {
		args := GetTaskArgs{}
		reply := GetTaskReply{}
		call("Coordinator.HandleGetTasks", &args, &reply)
		fmt.Println("I sent a request and got this as a reply", reply)
		
		switch reply.TaskType{
		case Map:
			performMap(reply.TaskNum, reply.FileName, reply.NumReduceTasks, mapf);
		case Reduce:
			performReduce(reply.TaskNum, reply.NumMapTasks, reducef)
		case Done:
			//no more tasks to be give, time to exit
			os.Exit(0)
		default:
			log.Fatalf("bad task type %v", reply.TaskType)
		}
		finArgs := FinishedTaskArgs{
			TaskType: reply.TaskType,
			TaskNum: reply.TaskNum,
		}
		finReply := FinishedTaskReply{}
		call("Coordinator.HandleFinishTasks", &finArgs, &finReply)

	}
	
}

func performReduce(TaskNum int, NumMapTasks int, 
	reducef func(string, []string) string){
	//fmt.Println("performing reduce on", TaskNum, NumMapTasks)
	kva := []KeyValue{}
	//open all files for this reduce task and append the values
	//to kva
	for m := 0; m < NumMapTasks; m++{
		fileName := getIntermediateFileName(m, TaskNum)
		file, err := os.Open(fileName)
		if err != nil{
			log.Fatalf("cant open file %v", fileName)
		}
		dec := json.NewDecoder(file)
		for {
			var kv KeyValue
			if err := dec.Decode(&kv); err != nil{
				break;
			}
			kva = append(kva, kv)
		}
	}

	sort.Sort(ByKey(kva))
	file, err := ioutil.TempFile("", "")
	fileName := file.Name()
	if err != nil{
		log.Fatalf("unable to create temp file %v", err)
	}

	//
	// call Reduce on each distinct key in kva[],
	// and print the result to mr-out-0.
	//
	i := 0
	for i < len(kva) {
		j := i + 1
		for j < len(kva) && kva[j].Key == kva[i].Key {
			j++
		}
		values := []string{}
		for k := i; k < j; k++ {
			values = append(values, kva[k].Value)
		}
		output := reducef(kva[i].Key, values)

		// this is the correct format for each line of Reduce output.
		fmt.Fprintf(file, "%v %v\n", kva[i].Key, output)

		i = j
	}	
	file.Close()
	finalizeRenameReduceTasks(fileName, TaskNum)
}
func performMap(TaskNum int, FileName string, 
	NumReduceTasks int, mapf func(string, string) []KeyValue){

	//get file contents
	file, err := os.Open(FileName)
	if err != nil{
		log.Fatalf("cant open file %v", FileName)
	}
	fileContent, err := ioutil.ReadAll(file)
	if err != nil{
		log.Fatalf("cant read file %v", FileName)
	}
	file.Close()

	//get keyValue pairs from mpf
	kva := mapf(FileName, string(fileContent))

	//create temporary intermediate files to store kva pairs in
	tempFiles := []*os.File{}
	tempFileNames := []string{}
	encoders := []*json.Encoder{}
	for r:= 0; r < NumReduceTasks; r++{
		file, err := ioutil.TempFile("", "")
		if err != nil{
			log.Fatalf("unable to create temp file %v", err)
		}
		tempFiles = append(tempFiles, file)
		tempFileName := file.Name()
		tempFileNames = append(tempFileNames, tempFileName)
		encoders = append(encoders, json.NewEncoder(file))
	}

	//write kv pairs to files the size of reduce tasks
	for _, val := range kva {
		idx := ihash(val.Key) % NumReduceTasks
		err := encoders[idx].Encode(&val)
		if err != nil{
			log.Fatalf("unable to encode this kv pair %v", val)
		}
	}

	for r:= 0; r < NumReduceTasks; r++{
		//close all temporary files
		tempFiles[r].Close()
	}

	//rename all temporary files to finalized intermediate files
	for r := 0; r < NumReduceTasks; r++{
		finalizeRenameTemporaryIntermediateFiles(tempFileNames[r], TaskNum, r)
	}		
}

//
// send an RPC request to the coordinator, wait for the response.
// usually returns true.
// returns false if something goes wrong.
//
func call(rpcname string, args interface{}, reply interface{}) bool {
	// c, err := rpc.DialHTTP("tcp", "127.0.0.1"+":1234")
	sockname := coordinatorSock()
	c, err := rpc.DialHTTP("unix", sockname)
	if err != nil {
		log.Fatal("dialing:", err)
	}
	defer c.Close()

	err = c.Call(rpcname, args, reply)
	if err == nil {
		return true
	}

	fmt.Println(err)
	return false
}